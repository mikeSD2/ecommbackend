package com.springboot.mySpringBootCRUDapp.dao;

import org.springframework.data.jpa.repository.JpaRepository;
import com.springboot.mySpringBootCRUDapp.entity.Customer;
//!!!Теперь подготовим бекенд для принятия данных пормы.
//
//Создадим Таблицы БД. Покупатель, заказы, товары заказов и колличество товаров какого-то цвета. Связи такие: у одного покупателя может быть много заказов (1коМногим),
//один заказ может включать в себя много товаров(1коМногим), и поскольку покупатнль может купить один и тот же товар нескольких цветов
//то будет еще одна таблица где будут все купленные покупателем цвета и колличества этих цветов одного и того же товара (1коМногоим). 
//Создаем таблицы SQL коммандой. Содаем их entity классы на бекенде.
//Далее нам нужно будет создать класс Purchase. на фронтенде в котором будут отправляться данные введенные пользователем в форму из 
//фронта и такой же класс на бекенде который будет принимать данные с фронта.

//Дальше важный момент. Чтобы принять Purchase обьект на бекенде мы не будем создавать для Purchase репозиторий как мы это делали с другими классами.
//Во первых Purchase это Data Transfer Object а не entity базы данных. тоесть это просто класс который будет принимать JSON такого же класса Purchase с фронта
//и этот JSON будет за кулисами конвертироваться с помощью jackson в обьект Purchase здесь на бекенде и мы бы в любом случае не смогли создать репозиторий Purchase
//так как он не являеться entity БД. Во вторых репозиторий автоматически генерирует ссылки и методы которые обеспечивают лишь простые
//CRUD операции с БД, а у нас будет своя дополнительная логика обработки принятого с фронта обьекта Purchase.
//Поэтому поступим по старинке без Spring Data Rest фич. Будем создавать контроллер который принимает Purchase 
//обьект и сервис который этот обьект обрабатывает.

//Ниже создаем репозиторий Покупателя. Как помним автоматически предоставлябться методы работы с БД (save(), update() и т.д)
//Которые нам пригодяться в сервисе для обработки Purchase.

public interface CustomerRepository extends JpaRepository<Customer, Long> {
//  !!!Сделаем так чтобы в БД в таблице Покупатель не было дубликатов имейлов.
//	это нужно поскольку дальше нам нужно будет выбирать из БД заказы которые связаны
//	с okta аккаунтом пользователя. На фронте будем выбирать имейл okta аккаунта присылать его сюда
//	и по нему выбирать заказы.
//
//  Сначала в репозитории покупателя создаем метод котоырй будет совершать sql запрос. 
//	Он для выборки пользователей по имейлу. 
//  Запрос будет таким SELECT * FROM customer WHERE email = email.
//  Кстате раньше мы использовали методы в репозиториях для обращения к ним по ссылкам
//	которые эти репозитории генерируют. Этот метод мы будем чисто вызывать здесь на бекенде
//	в классе OrderProcessingServiceImpl и никакие ссылки нам не нужны. Тоесть запомните
//  что в репозиториях можно создавать методы просто для выборки каких-то нужных здесь на бекенде данных,
//  а не только для обращения к ним по сгенерированным методом ссилкам.
	Customer findByEmail(String email);
}

//!!!Репозиторий покупателя например нам нужен только чтобы извлечь имейл с помощью метода который мы используем.
//И мы не хотим чтобы этот репозиторий автоматически генерировал адреса для взаимодействия с БД. В конфигурациях 
//Spring Boot можно откключить эту генерацию. Это делаеться в файле application.properties установкой глобального поля spring.data.rest.detection-strategy={значение}.
//Значение Annotated означает что автоматически генрироваться ссылки будет только
//для репозиториев с аннотацией @ReporsitoryRestResource. Также есть еще VISIBILITY ссылки генерируються для всех
//public репозиториев, DEFAULT - генерация для public репозиториев или тех которые помечены аннотацией и 
//ALL генерируються для всех репозиториев с аннотацией или без, public или не public.
